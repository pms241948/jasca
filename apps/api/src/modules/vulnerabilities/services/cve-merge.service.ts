import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';

export interface MergedCveGroup {
    primaryCveId: string;
    mergedCveIds: string[];
    affectedPackages: {
        name: string;
        version: string;
        type: string;
        scanResultIds: string[];
    }[];
    mergeReason: string;
}

export interface CveMergeResult {
    totalOriginal: number;
    totalMerged: number;
    mergeGroups: MergedCveGroup[];
}

@Injectable()
export class CveMergeService {
    private readonly logger = new Logger(CveMergeService.name);

    constructor(private readonly prisma: PrismaService) { }

    /**
     * Identify and merge duplicate CVEs from scan results
     * A CVE is considered duplicate when:
     * - Same CVE ID appears in multiple package types (OS + library)
     * - Same CVE affects same package with different paths
     */
    async identifyDuplicates(scanResultId: string): Promise<MergedCveGroup[]> {
        const vulnerabilities = await this.prisma.scanVulnerability.findMany({
            where: { scanResultId },
            include: {
                vulnerability: true,
            },
        });

        // Group by CVE ID
        const cveGroups = new Map<string, typeof vulnerabilities>();

        for (const vuln of vulnerabilities) {
            const cveId = vuln.vulnerability.cveId;
            const existing = cveGroups.get(cveId) || [];
            existing.push(vuln);
            cveGroups.set(cveId, existing);
        }

        const mergeGroups: MergedCveGroup[] = [];

        for (const [cveId, vulns] of cveGroups.entries()) {
            if (vulns.length > 1) {
                // Check if these are truly duplicates (same package, different paths)
                const packageGroups = this.groupByPackage(vulns);

                for (const [packageKey, packageVulns] of packageGroups.entries()) {
                    if (packageVulns.length > 1) {
                        mergeGroups.push({
                            primaryCveId: cveId,
                            mergedCveIds: packageVulns.map(v => v.id),
                            affectedPackages: [{
                                name: packageVulns[0].pkgName,
                                version: packageVulns[0].pkgVersion,
                                type: this.detectPackageType(packageVulns[0].pkgPath || ''),
                                scanResultIds: [scanResultId],
                            }],
                            mergeReason: `Duplicate CVE ${cveId} in package ${packageKey}`,
                        });
                    }
                }
            }
        }

        return mergeGroups;
    }

    /**
     * Merge CVEs across multiple scan results
     */
    async mergeCvesAcrossScans(projectId: string): Promise<CveMergeResult> {
        const scanResults = await this.prisma.scanResult.findMany({
            where: { projectId },
            include: {
                vulnerabilities: {
                    include: { vulnerability: true },
                },
            },
            orderBy: { createdAt: 'desc' },
        });

        // Build CVE -> scan results mapping
        const cveToScans = new Map<string, {
            vulnId: string;
            scanResultId: string;
            pkgName: string;
            pkgVersion: string;
            pkgPath?: string;
        }[]>();

        for (const scan of scanResults) {
            for (const vuln of scan.vulnerabilities) {
                const cveId = vuln.vulnerability.cveId;
                const existing = cveToScans.get(cveId) || [];
                existing.push({
                    vulnId: vuln.id,
                    scanResultId: scan.id,
                    pkgName: vuln.pkgName,
                    pkgVersion: vuln.pkgVersion,
                    pkgPath: vuln.pkgPath || undefined,
                });
                cveToScans.set(cveId, existing);
            }
        }

        const mergeGroups: MergedCveGroup[] = [];
        let totalOriginal = 0;

        for (const [cveId, occurrences] of cveToScans.entries()) {
            totalOriginal += occurrences.length;

            // Group by package name + version to find true duplicates
            const packageGroups = new Map<string, typeof occurrences>();

            for (const occ of occurrences) {
                const key = `${occ.pkgName}@${occ.pkgVersion}`;
                const existing = packageGroups.get(key) || [];
                existing.push(occ);
                packageGroups.set(key, existing);
            }

            for (const [packageKey, pkgOccurrences] of packageGroups.entries()) {
                if (pkgOccurrences.length > 1) {
                    // These are duplicates - same CVE, same package, different scans/paths
                    const [pkgName, pkgVersion] = packageKey.split('@');

                    mergeGroups.push({
                        primaryCveId: cveId,
                        mergedCveIds: pkgOccurrences.map(o => o.vulnId),
                        affectedPackages: [{
                            name: pkgName,
                            version: pkgVersion,
                            type: this.detectPackageType(pkgOccurrences[0].pkgPath || ''),
                            scanResultIds: [...new Set(pkgOccurrences.map(o => o.scanResultId))],
                        }],
                        mergeReason: `Same CVE ${cveId} affects ${packageKey} across ${pkgOccurrences.length} occurrences`,
                    });
                }
            }
        }

        return {
            totalOriginal,
            totalMerged: cveToScans.size,
            mergeGroups,
        };
    }

    /**
     * Get unique CVE count for a project (after merge)
     */
    async getUniqueCveCount(projectId: string): Promise<{
        total: number;
        bySeverity: Record<string, number>;
        duplicateCount: number;
    }> {
        const scanResults = await this.prisma.scanResult.findMany({
            where: { projectId },
            include: {
                vulnerabilities: {
                    include: { vulnerability: true },
                },
            },
        });

        const uniqueCves = new Map<string, { severity: string }>();
        let totalOccurrences = 0;

        for (const scan of scanResults) {
            for (const vuln of scan.vulnerabilities) {
                totalOccurrences++;
                const cveId = vuln.vulnerability.cveId;
                if (!uniqueCves.has(cveId)) {
                    uniqueCves.set(cveId, { severity: vuln.vulnerability.severity });
                }
            }
        }

        const bySeverity: Record<string, number> = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
            UNKNOWN: 0,
        };

        for (const [_, data] of uniqueCves) {
            bySeverity[data.severity] = (bySeverity[data.severity] || 0) + 1;
        }

        return {
            total: uniqueCves.size,
            bySeverity,
            duplicateCount: totalOccurrences - uniqueCves.size,
        };
    }

    /**
     * Create merge record in database
     * Note: Requires Prisma client regeneration after migration
     */
    async createMergeRecord(mergeGroup: MergedCveGroup): Promise<void> {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        await (this.prisma as any).mergedVulnerability.create({
            data: {
                cveId: mergeGroup.primaryCveId,
                primaryVulnId: mergeGroup.mergedCveIds[0],
                mergedVulnIds: mergeGroup.mergedCveIds.slice(1),
                mergeReason: mergeGroup.mergeReason,
            },
        });
    }

    // Helper methods

    private groupByPackage(vulns: any[]): Map<string, any[]> {
        const groups = new Map<string, any[]>();

        for (const vuln of vulns) {
            const key = `${vuln.pkgName}@${vuln.pkgVersion}`;
            const existing = groups.get(key) || [];
            existing.push(vuln);
            groups.set(key, existing);
        }

        return groups;
    }

    private detectPackageType(pkgPath: string): string {
        if (!pkgPath) return 'unknown';

        const lowerPath = pkgPath.toLowerCase();

        if (lowerPath.includes('node_modules') || lowerPath.includes('package.json')) {
            return 'npm';
        }
        if (lowerPath.includes('requirements.txt') || lowerPath.includes('site-packages')) {
            return 'pip';
        }
        if (lowerPath.includes('.jar') || lowerPath.includes('pom.xml')) {
            return 'maven';
        }
        if (lowerPath.includes('go.mod') || lowerPath.includes('go.sum')) {
            return 'go';
        }
        if (lowerPath.includes('gemfile') || lowerPath.includes('.gem')) {
            return 'gem';
        }
        if (lowerPath.includes('/var/lib/dpkg') || lowerPath.includes('.deb')) {
            return 'debian';
        }
        if (lowerPath.includes('/var/lib/rpm') || lowerPath.includes('.rpm')) {
            return 'redhat';
        }
        if (lowerPath.includes('/lib/apk')) {
            return 'alpine';
        }

        return 'os';
    }
}
